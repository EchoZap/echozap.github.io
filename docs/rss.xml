<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Ronan's Blog</title><link>https://echozap.github.io</link><description>接受过《中华人民共和国义务教育法》规定的完整「九年义务教育」，如今也是个「正儿八经」的「文化人」，目前的物理活动范围主要在「某东亚大国」。</description><copyright>Ronan's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/avatar.jpg</url><title>avatar</title><link>https://echozap.github.io</link></image><lastBuildDate>Sat, 22 Mar 2025 09:50:25 +0000</lastBuildDate><managingEditor>Ronan's Blog</managingEditor><ttl>60</ttl><webMaster>Ronan's Blog</webMaster><item><title>软链接的使用，以 python 举例</title><link>https://echozap.github.io/post/ruan-lian-jie-de-shi-yong-%EF%BC%8C-yi-%20python%20-ju-li.html</link><description>在 macOS 上创建和使用软链接（symbolic link）的操作非常实用，特别是在管理不同版本的 Python 时。</description><guid isPermaLink="true">https://echozap.github.io/post/ruan-lian-jie-de-shi-yong-%EF%BC%8C-yi-%20python%20-ju-li.html</guid><pubDate>Tue, 27 Aug 2024 04:55:09 +0000</pubDate></item><item><title>npm常用用法</title><link>https://echozap.github.io/post/npm-chang-yong-yong-fa.html</link><description>你可以使用以下命令查看已经通过 `npm` 安装的包：

### 1. **查看全局安装的包**

要查看全局安装的所有包，可以运行以下命令：

```bash
npm list -g --depth=0
```

这个命令会列出所有全局安装的包，并且使用 `--depth=0` 选项只显示顶级包，不显示它们的依赖项。</description><guid isPermaLink="true">https://echozap.github.io/post/npm-chang-yong-yong-fa.html</guid><pubDate>Mon, 26 Aug 2024 04:31:13 +0000</pubDate></item><item><title>JavasSript常用方法</title><link>https://echozap.github.io/post/JavasSript-chang-yong-fang-fa.html</link><description># 获取 DOM 节点

### 1.选择匹配到的第一个元素

**语法：**

```javascript
document.querySelector('css选择器')
```

**参数：**

包含一个或多个有效的css选择器 **字符串** ，查看 [更多css选择器](https://www.runoob.com/cssref/css-selectors.html)。</description><guid isPermaLink="true">https://echozap.github.io/post/JavasSript-chang-yong-fang-fa.html</guid><pubDate>Sun, 25 Aug 2024 05:07:16 +0000</pubDate></item><item><title>macOS去除重复PATH环境变量</title><link>https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</link><description>&gt; [!important]
&gt;
&gt; 环境变量分为系统和用户，这里主要配置用户环境

在 macOS 上，全局的系统环境变量文件通常可以通过以下文件和目录来配置：

1. **`/etc/profile`**：

- 这是系统范围的 shell 配置文件，适用于所有用户。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</guid><pubDate>Sat, 24 Aug 2024 03:57:57 +0000</pubDate></item><item><title>「python」Conda虚拟环境</title><link>https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8DConda-xu-ni-huan-jing.html</link><description># 创建一个新的虚拟环境&#13;
&#13;
可以使用以下命令创建一个名为 `jupyter_env` 的新环境，并指定 Python 版本（例如 Python 3.11）&#13;
&#13;
```shell&#13;
conda create -n jupyter_env python=3.11&#13;
```&#13;
&#13;
&gt; [!tip]&#13;
&gt;&#13;
&gt; 通过上面命令创建的虚拟环境通常会保存在主环境目录，如果想指定虚拟环境的位置，可以使用下面的命令&#13;
&#13;
**指定路径**：如果你在创建环境时使用了 `-p` 或 `--prefix` 选项指定路径，环境会存储在你指定的位置。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8DConda-xu-ni-huan-jing.html</guid><pubDate>Fri, 23 Aug 2024 11:02:51 +0000</pubDate></item><item><title>JavaScript</title><link>https://echozap.github.io/post/JavaScript.html</link><description># 对象概述

什么是对象？对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合

![image-20211025173456785](https://wowpb.pages.dev/file/b4faace2de4b182e5e956.png)

```js
var user = {
  name: 'itbaizhan',
  age: '13'
};
```

对象的每一个键名又称为“属性”（property），它的“键

值”可以是任何数据类型。</description><guid isPermaLink="true">https://echozap.github.io/post/JavaScript.html</guid><pubDate>Thu, 22 Aug 2024 04:48:42 +0000</pubDate></item><item><title>Dockerfile的简单实现</title><link>https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</link><description># 构建第一个Dockerfile

假设该镜像实现的等同于我们在已经配置好python环境的机器上通过`python hello.py`命令来运行一个python脚本

所以该Dockerfile的构建有以下步骤：

1. 在桌面或其他位置新建一个文件夹，假设文件夹名为docker
2. 在docker新建一个hello.py文件，hello.py已经实现所需功能
3. 再在docker新建一个`Dockerfile`，**注意：仅开头且必须大写**

以下是Dockerfile内容：

```shell
FROM python:3.9.19-alpine3.18
COPY hello.py /hello.py
CMD python hello.py
```

# Dockerfile语法说明

`Dockerfile` 是 Docker 构建镜像的描述文件，它包含了一系列指令，描述了如何从基础镜像创建一个新的 Docker 镜像。</description><guid isPermaLink="true">https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</guid><pubDate>Thu, 22 Aug 2024 04:22:16 +0000</pubDate></item><item><title>fire,一个强大的「python」库</title><link>https://echozap.github.io/post/fire%2C-yi-ge-qiang-da-de-%E3%80%8Cpython%E3%80%8D-ku.html</link><description>Github地址：[https://github.com/google/python-fire](https://github.com/google/python-fire)

在开发命令行工具时，开发者通常需要编写大量代码来解析命令行参数，这既耗时又容易出错。</description><guid isPermaLink="true">https://echozap.github.io/post/fire%2C-yi-ge-qiang-da-de-%E3%80%8Cpython%E3%80%8D-ku.html</guid><pubDate>Thu, 22 Aug 2024 03:55:12 +0000</pubDate></item><item><title>vscode个人配置文件</title><link>https://echozap.github.io/post/vscode-ge-ren-pei-zhi-wen-jian.html</link><description>&gt; [!note]&#13;
&gt;&#13;
&gt; 以下为个人自用配置文件，如需拷贝使用请把 **插件配置区** 的选项删除或者安装相应的插件。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-ge-ren-pei-zhi-wen-jian.html</guid><pubDate>Wed, 21 Aug 2024 05:25:54 +0000</pubDate></item><item><title>他决定偷一架飞机</title><link>https://echozap.github.io/post/ta-jue-ding-tou-yi-jia-fei-ji.html</link><description>
2018年8月10日，地平线航空一架庞巴迪Dash 8 Q400在美国西雅图的塔科马国际机场（Sea-Tac）被盗。</description><guid isPermaLink="true">https://echozap.github.io/post/ta-jue-ding-tou-yi-jia-fei-ji.html</guid><pubDate>Wed, 21 Aug 2024 01:56:12 +0000</pubDate></item><item><title>「python」打包程序</title><link>https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8D-da-bao-cheng-xu.html</link><description># 通过pyinstaller打包

要将Python脚本打包成一个独立运行的应用程序，可以使用工具PyInstaller，其可以将Python脚本打包成一个可执行文件 (.exe) 。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8D-da-bao-cheng-xu.html</guid><pubDate>Tue, 20 Aug 2024 00:44:46 +0000</pubDate></item><item><title>shell 文本、字符串处理</title><link>https://echozap.github.io/post/shell%20-wen-ben-%E3%80%81-zi-fu-chuan-chu-li.html</link><description>&#13;
## 1、字符串切片&#13;
＄{变量：偏移量：截取长度｝&#13;
&#13;
```shell&#13;
--------------------------example&#13;
[192.168.2.230] - root@ubuntu20.04.5-template:/ root&#13;
$ MYPATH=' /usr/bin/wget'&#13;
&#13;
[192.168.2.230］ - root@ubuntu20.04.5-template:/root&#13;
$ echo ${MYPATH: 4:4}&#13;
/bin     			  #其会左向右从第四位向后取四位（字符串第一位为0）&#13;
&#13;
[192.168.2.230] - root@ubuntu20.04.5-template:/ root&#13;
$ echo ${MYPATH: -4}  #这会右向左从末尾向前取四位，「-4和冒号之间要有一个空格」&#13;
```&#13;
&#13;
## 2、基于模式取子串&#13;
${var#*word}&#13;
其中word可以是指定的任意字符，自左而右，删除字符串开头至第一次出现word字符之间的所有字符。</description><guid isPermaLink="true">https://echozap.github.io/post/shell%20-wen-ben-%E3%80%81-zi-fu-chuan-chu-li.html</guid><pubDate>Wed, 14 Aug 2024 15:01:58 +0000</pubDate></item><item><title>个人自用vim配置文件</title><link>https://echozap.github.io/post/ge-ren-zi-yong-vim-pei-zhi-wen-jian.html</link><description>将以下内容写入 `.vimrc` 中


```
' 开启系统剪切板
set clipboard=unnamedplus


' 将 jk 映射为 Esc
inoremap jk &lt;Esc&gt;


' 开启行号显示
set nu


' 开启自动缩进并将 tab 键设置为四个空格长度
set autoindent
set shiftwidth=4
set tabstop=4
set expandtab


' 启用自动补全
set omnifunc=syntaxcomplete#Complete

' 设置自动匹配括号
' inoremap ( ()&lt;Left&gt;
inoremap { {}&lt;Left&gt;
inoremap [ []&lt;Left&gt;


' 设置代码语法高亮
syntax on
```

&lt;!-- ##{'timestamp':1723621841}## --&gt;
。</description><guid isPermaLink="true">https://echozap.github.io/post/ge-ren-zi-yong-vim-pei-zhi-wen-jian.html</guid><pubDate>Wed, 14 Aug 2024 07:50:41 +0000</pubDate></item><item><title>「Python」模块和包</title><link>https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-mo-kuai-he-bao.html</link><description>Python 提供了强大的模块支持，主要体现在，不仅 Python 标准库中包含了大量的模块（称为标准模块），还有大量的第三方模块，开发者自己也可以开发自定义模块。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-mo-kuai-he-bao.html</guid><pubDate>Tue, 13 Aug 2024 09:29:17 +0000</pubDate></item><item><title>「Python」异常处理</title><link>https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-yi-chang-chu-li.html</link><description>在 Python 中，常见的基本错误有两类，即语法错误和异常。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-yi-chang-chu-li.html</guid><pubDate>Tue, 13 Aug 2024 07:58:22 +0000</pubDate></item><item><title>GCC</title><link>https://echozap.github.io/post/GCC.html</link><description>&#13;
**GCC** 是 Linux 下的编译工具集，是 **GNU Compiler Collection** 的缩写，包含 gcc、g++ 等编译器。</description><guid isPermaLink="true">https://echozap.github.io/post/GCC.html</guid><pubDate>Sun, 11 Aug 2024 17:49:03 +0000</pubDate></item><item><title>「OrbStack」Mac 系统中一个更快的 Docker 可视化工具，可完全替代 Docker Desktop</title><link>https://echozap.github.io/post/%E3%80%8COrbStack%E3%80%8DMac%20-xi-tong-zhong-yi-ge-geng-kuai-de-%20Docker%20-ke-shi-hua-gong-ju-%EF%BC%8C-ke-wan-quan-ti-dai-%20Docker%20Desktop.html</link><description>&#13;
我之前用的是 Docker Desktop，每次准备启动容器的时候，我都会把能关的应用都关闭，省的电脑卡， Docker Desktop 确实有点儿耗性能。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8COrbStack%E3%80%8DMac%20-xi-tong-zhong-yi-ge-geng-kuai-de-%20Docker%20-ke-shi-hua-gong-ju-%EF%BC%8C-ke-wan-quan-ti-dai-%20Docker%20Desktop.html</guid><pubDate>Thu, 08 Aug 2024 13:53:24 +0000</pubDate></item><item><title>Docker常用命令</title><link>https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</link><description>![DockerCheatSheet.png](https://wowpb.pages.dev/file/38386b215292115008331.png)&#13;
&#13;
# 列出所有已下载镜像&#13;
```shell&#13;
❯ docker images&#13;
REPOSITORY        TAG       IMAGE ID       CREATED         SIZE&#13;
ubuntu            latest    ffb64c9b7e8b   3 weeks ago     101MB&#13;
b3log/siyuan      latest    caf98195a3c3   3 weeks ago     220MB&#13;
soulteary/flare   latest    843d799dc8b2   2 months ago    12.8MB&#13;
hello-world       latest    ee301c921b8a   14 months ago   9.14kB&#13;
``` &#13;
&#13;
# 列出当前所有容器&#13;
```shell&#13;
❯ docker ps -a&#13;
CONTAINER ID   IMAGE     COMMAND                   CREATED              STATUS      &#13;
2295f62c584b   ubuntu    '/bin/sh -c 'while t…'   1 minute ago   Up About a minute&#13;
526462e8b92d   ubuntu    '/bin/bash'               44 minutes ago       Exited (0) &#13;
``` &#13;
&#13;
输出详情介绍：&#13;
- **CONTAINER ID:**  容器 ID。</description><guid isPermaLink="true">https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</guid><pubDate>Sat, 03 Aug 2024 07:08:59 +0000</pubDate></item><item><title>ffmpeg常用用法</title><link>https://echozap.github.io/post/ffmpeg-chang-yong-yong-fa.html</link><description># 不改变原视频码率裁剪&#13;
### 废话少说，直接举栗🌰&#13;
1.从 `1时15分25秒` 开始裁剪到视频结束： &#13;
```shell&#13;
ffmpeg -i input.mp4 -ss 01:15:25 -c copy output.mp4&#13;
``` &#13;
&#13;
2.从 `视频开始到15分5秒` ：&#13;
```shell&#13;
ffmpeg -i input.mp4 -to 00:15:05 -c copy output.mp4&#13;
```  &#13;
&#13;
3.从 `15分25秒` 到  `1时15分25秒` ：&#13;
```shell&#13;
ffmpeg -i input.mp4 -ss 15:25 -to 01:15:25 -c copy output.mp4&#13;
``` &#13;
  &#13;
`-i` 指定输入视频路径，`input.mp4`是要裁剪的视频文件的路径， `-ss` 裁剪视频起始时间，`-to` 裁剪视频结束时间，`-c copy` 在裁剪时不改变视频编码，从而保持原始视频码率， `output.mp4` 为裁剪后的视频文件。</description><guid isPermaLink="true">https://echozap.github.io/post/ffmpeg-chang-yong-yong-fa.html</guid><pubDate>Sat, 03 Aug 2024 06:54:09 +0000</pubDate></item><item><title>「Gmeek」上传脚本(单篇或批量)</title><link>https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-shang-chuan-jiao-ben-%28-dan-pian-huo-pi-liang-%29.html</link><description>&gt; [!caution]&#13;
&gt;&#13;
&gt; **注意：** 该脚本仅适用于通过Gmeek项目搭建的博客网站&#13;
&gt; 在开始使用之前，需要创建 github 的个人 Token&#13;
&#13;
&#13;
# 1.创建github个人Token&#13;
&#13;
1.在 GitHub 上任何页面的**右上角**，单击您的`个人资料照片`，然后单击 `Settings`。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-shang-chuan-jiao-ben-%28-dan-pian-huo-pi-liang-%29.html</guid><pubDate>Fri, 02 Aug 2024 15:09:42 +0000</pubDate></item><item><title>「Gmeek」文章插入html标签以及图片源地址渲染</title><link>https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-wen-zhang-cha-ru-html-biao-qian-yi-ji-tu-pian-yuan-di-zhi-xuan-ran.html</link><description># 1.图片使用创建文章(issue)时输入的原始链接。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-wen-zhang-cha-ru-html-biao-qian-yi-ji-tu-pian-yuan-di-zhi-xuan-ran.html</guid><pubDate>Fri, 02 Aug 2024 14:51:38 +0000</pubDate></item><item><title>「Gmeek」小Tips以及常见问题</title><link>https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-xiao-Tips-yi-ji-chang-jian-wen-ti.html</link><description># 修改文章发布时间&#13;
如需修改发布时间，可以在文章 `最后一行(后面不能有空行)` 添加如下代码。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CGmeek%E3%80%8D-xiao-Tips-yi-ji-chang-jian-wen-ti.html</guid><pubDate>Fri, 02 Aug 2024 11:34:06 +0000</pubDate></item><item><title>macOS电池管理脚本</title><link>https://echozap.github.io/post/macOS-dian-chi-guan-li-jiao-ben.html</link><description>将以下内容保存为 `power_manager.sh` 并放入系统环境变量的路径中，接下来可通过 `nohub /path/power_manager.sh &amp;` 来实现后台运行&#13;
&#13;
```&#13;
#!/bin/zsh&#13;
&#13;
# 关闭休眠&#13;
disable_sleep() {&#13;
    sudo pmset -b sleep 0&#13;
    sudo pmset -b disablesleep 1&#13;
}&#13;
&#13;
# 启用休眠&#13;
enable_sleep() {&#13;
    sudo pmset -b sleep 5&#13;
    sudo pmset -b disablesleep 0&#13;
}&#13;
&#13;
while true; do&#13;
&#13;
    LOG_FILE='/Users/a1/power_manager.log'&#13;
&#13;
    # 获取电脑盖子状态&#13;
    lid_state=$(ioreg -r -k AppleClamshellState -d 4 | grep AppleClamshellState | head -1 | awk '{print $NF}')&#13;
&#13;
    # 获取电源连接状态&#13;
    ac_state=$(pmset -g batt | head -1)&#13;
&#13;
    if [[ $lid_state == 'Yes' ]]; then&#13;
    # 合盖状态&#13;
        if [[ $ac_state =~ 'AC' ]]; then&#13;
            # 连接电源，关闭休眠并立即保持系统唤醒&#13;
            disable_sleep&#13;
        else&#13;
            # 未连接电源，开启休眠并立即进入休眠&#13;
            enable_sleep&#13;
            pmset sleepnow&#13;
        fi&#13;
    else&#13;
    # 开盖状态&#13;
        if [[ $ac_state =~ 'AC' ]]; then&#13;
            # 连接电源，关闭休眠并保持系统唤醒&#13;
            disable_sleep&#13;
        else&#13;
            # 未连接电源，开启休眠但不立即进入休眠&#13;
            enable_sleep&#13;
        fi&#13;
    fi&#13;
    sleep 5&#13;
done&#13;
```。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-dian-chi-guan-li-jiao-ben.html</guid><pubDate>Fri, 02 Aug 2024 06:08:01 +0000</pubDate></item><item><title>「Python」虚拟环境</title><link>https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-xu-ni-huan-jing.html</link><description>*在虚拟环境中，pip 和 pip3 通常会指向同一个 Python 版本的包管理器。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8CPython%E3%80%8D-xu-ni-huan-jing.html</guid><pubDate>Mon, 29 Jul 2024 12:48:40 +0000</pubDate></item><item><title>「python」查看或切换当前解释器</title><link>https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8D-cha-kan-huo-qie-huan-dang-qian-jie-shi-qi.html</link><description># 查看系统中所有安装的 Python 解释器&#13;
```&#13;
which -a python python3&#13;
```&#13;
这会列出系统路径中找到的 python 和 python3 解释器的位置:&#13;
```&#13;
❯ which -a python python3&#13;
&#13;
python not found&#13;
/usr/bin/python3&#13;
/opt/homebrew/bin/python3&#13;
```&#13;
`-a` 选项确保显示所有匹配的路径，而不仅仅是第一个。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8Cpython%E3%80%8D-cha-kan-huo-qie-huan-dang-qian-jie-shi-qi.html</guid><pubDate>Mon, 29 Jul 2024 11:44:59 +0000</pubDate></item><item><title>「各种摸不着头脑」意外修改PATH(环境变量)</title><link>https://echozap.github.io/post/%E3%80%8C-ge-zhong-mo-bu-zhao-tou-nao-%E3%80%8D-yi-wai-xiu-gai-PATH%28-huan-jing-bian-liang-%29.html</link><description># 1. **检查sudo是否已经安装**&#13;
&#13;
确保 **sudo** 已经正确地安装在你的系统中。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8C-ge-zhong-mo-bu-zhao-tou-nao-%E3%80%8D-yi-wai-xiu-gai-PATH%28-huan-jing-bian-liang-%29.html</guid><pubDate>Sun, 28 Jul 2024 09:55:30 +0000</pubDate></item><item><title>Linux查看或修改主机名</title><link>https://echozap.github.io/post/Linux-cha-kan-huo-xiu-gai-zhu-ji-ming.html</link><description># 1查看当前主机名&#13;
&#13;
```plain&#13;
hostname&#13;
```&#13;
&#13;
这将会显示当前的主机名，或者&#13;
&#13;
```zsh&#13;
cat /etc/hostname&#13;
```&#13;
  &#13;
&#13;
# 2修改主机名&#13;
&#13;
使用以下命令设置新主机名&#13;
&#13;
```zsh&#13;
sudo hostnamectl set-hostname &lt;new_hostname&gt;&#13;
```&#13;
&#13;
之后在文件中找到包含旧主机名的行，并将其替换为新主机名。</description><guid isPermaLink="true">https://echozap.github.io/post/Linux-cha-kan-huo-xiu-gai-zhu-ji-ming.html</guid><pubDate>Sun, 28 Jul 2024 09:46:14 +0000</pubDate></item><item><title>「国内解决方法」linux安装docker</title><link>https://echozap.github.io/post/%E3%80%8C-guo-nei-jie-jue-fang-fa-%E3%80%8Dlinux-an-zhuang-docker.html</link><description># 1.安装Docker&#13;
&#13;
一键安装命令&#13;
&#13;
```&#13;
sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun&#13;
```&#13;
&#13;
&gt; 备用（如果Github访问不了，可以使用Gitee的链接）&lt;br&gt;&#13;
&#13;
```&#13;
sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun&#13;
```&#13;
&#13;
启动docker&#13;
&#13;
```&#13;
sudo service docker start&#13;
```&#13;
&#13;
# 2.镜像拉取&#13;
&#13;
```zsh&#13;
bash -c '$(curl -sSLf https://xy.ggbond.org/xy/docker_pull.sh)' -s 完整镜像名&#13;
```&#13;
&#13;
如有额外需求，以下是`docker_pull.sh`：&#13;
&#13;
&lt;details&gt;&#13;
    &lt;summary&gt;点我查看docker_pull.sh&lt;/summary&gt;&#13;
    &lt;pre&gt;&lt;code&gt;&#13;
   &#13;
```zsh&#13;
#!/bin/bash&#13;
# shellcheck shell=bash&#13;
# shellcheck disable=SC2086&#13;
&#13;
PATH=${PATH}:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin:/opt/homebrew/bin&#13;
export PATH&#13;
&#13;
Blue='\033[1;34m'&#13;
Green='\033[1;32m'&#13;
Red='\033[1;31m'&#13;
Yellow='\033[1;33m'&#13;
NC='\033[0m'&#13;
INFO='[${Green}INFO${NC}]'&#13;
ERROR='[${Red}ERROR${NC}]'&#13;
WARN='[${Yellow}WARN${NC}]'&#13;
&#13;
function INFO() {&#13;
    echo -e '${INFO} ${1}'&#13;
}&#13;
function ERROR() {&#13;
    echo -e '${ERROR} ${1}'&#13;
}&#13;
function WARN() {&#13;
    echo -e '${WARN} ${1}'&#13;
}&#13;
&#13;
function docker_pull() {&#13;
    #[ -z '${config_dir}' ] &amp;&amp; get_config_path&#13;
    local config_dir=${2:-'/etc/xiaoya'}&#13;
    mkdir -p '${config_dir}'&#13;
    local mirrors=('docker.io' 'docker.fxxk.dedyn.io' 'docker.m.daocloud.io' 'docker.adysec.com' 'registry-docker-hub-latest-9vqc.onrender.com' 'docker.chenby.cn' 'dockerproxy.com' 'hub.uuuadc.top' 'docker.jsdelivr.fyi' 'docker.registry.cyou' 'dockerhub.anzu.vip')&#13;
    if [ -s '${config_dir}/docker_mirrors.txt' ]; then&#13;
        mirrors=()&#13;
        while IFS= read -r line; do&#13;
            mirrors+=('$line')&#13;
        done &lt; '${config_dir}/docker_mirrors.txt'&#13;
    else&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            printf '%s\n' '$mirror' &gt;&gt; '${config_dir}/docker_mirrors.txt'&#13;
        done&#13;
    fi&#13;
    if command -v timeout &gt; /dev/null 2&gt;&amp;1;then&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            INFO '正在测试${mirror}代理点的连接性……'&#13;
            if timeout 30 docker pull '${mirror}/library/hello-world:latest'; then&#13;
                INFO '${mirror}代理点连通性测试正常！正在为您下载镜像……'&#13;
                for i in {1..2}; do&#13;
                    if timeout 300 docker pull '${mirror}/${1}'; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        break;&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                done&#13;
                if [[ '${mirror}' == 'docker.io' ]];then&#13;
                    docker rmi 'library/hello-world:latest'&#13;
                    [ -n '$(docker images -q '${1}')' ] &amp;&amp; return 0&#13;
                else&#13;
                    docker rmi '${mirror}/library/hello-world:latest'&#13;
                    [ -n '$(docker images -q '${mirror}/${1}')' ] &amp;&amp; break&#13;
                fi&#13;
            fi&#13;
        done&#13;
    else&#13;
        timeout=20&#13;
        for mirror in '${mirrors[@]}'; do&#13;
            INFO '正在测试${mirror}代理点的连接性……'       &#13;
            docker pull '${mirror}/library/hello-world:latest' || true &amp;&#13;
            pid=$!&#13;
            count=0&#13;
            while kill -0 $pid 2&gt;/dev/null; do&#13;
                sleep 5&#13;
                count=$((count+5))&#13;
                if [ $count -ge $timeout ]; then&#13;
                    echo 'Command timed out'&#13;
                    kill $pid&#13;
                    break&#13;
                fi&#13;
            done&#13;
&#13;
            if [ $? -eq 0 ]; then&#13;
                INFO '${mirror}代理点连通性测试正常！正在为您下载镜像……'&#13;
                timeout=200&#13;
                for i in {1..2}; do&#13;
                    docker pull '${mirror}/${1}' || true &amp;&#13;
                    pid=$!&#13;
                    count=0&#13;
                    while kill -0 $pid 2&gt;/dev/null; do&#13;
                        sleep 5&#13;
                        count=$((count+5))&#13;
                        if [ $count -ge $timeout ]; then&#13;
                            echo 'Command timed out'&#13;
                            kill $pid&#13;
                            break&#13;
                        fi&#13;
                    done&#13;
                done&#13;
                if [[ '${mirror}' == 'docker.io' ]];then&#13;
                    docker rmi 'library/hello-world:latest'&#13;
                    if [ -n '$(docker images -q '${1}')' ]; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        return 0&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                else&#13;
                    docker rmi '${mirror}/library/hello-world:latest'&#13;
                    if [ -n '$(docker images -q '${mirror}/${1}')' ]; then&#13;
                        INFO '${1} 镜像拉取成功！'&#13;
                        sed -i '/${mirror}/d' '${config_dir}/docker_mirrors.txt'&#13;
                        sed -i '1i ${mirror}' '${config_dir}/docker_mirrors.txt'&#13;
                        break&#13;
                    else&#13;
                        WARN '${1} 镜像拉取失败，正在进行重试...'&#13;
                    fi&#13;
                fi&#13;
            fi&#13;
        done&#13;
    fi&#13;
&#13;
    if [ -n '$(docker images -q '${mirror}/${1}')' ]; then&#13;
        docker tag '${mirror}/${1}' '${1}'&#13;
        docker rmi '${mirror}/${1}'&#13;
        return 0&#13;
    else&#13;
        ERROR '已尝试所有镜像代理拉取失败，程序退出，请检查网络后再试！'&#13;
        exit 1       &#13;
    fi&#13;
}&#13;
&#13;
if [ -n '$1' ];then&#13;
    docker_pull $1 $2&#13;
else&#13;
    while :; do&#13;
        read -erp '请输入您要拉取镜像的完整名字（示例：ailg/alist:latest）：' pull_img&#13;
        [ -n '${pull_img}' ] &amp;&amp; break&#13;
    done&#13;
    docker_pull '${pull_img}'&#13;
fi&#13;
```&#13;
&lt;/code&gt;&lt;/pre&gt;&#13;
&lt;/details&gt;。</description><guid isPermaLink="true">https://echozap.github.io/post/%E3%80%8C-guo-nei-jie-jue-fang-fa-%E3%80%8Dlinux-an-zhuang-docker.html</guid><pubDate>Sun, 28 Jul 2024 09:34:41 +0000</pubDate></item><item><title>mac使用主机名代替IP地址进行ssh连接</title><link>https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</link><description># 1编辑本地SSH配置文件&#13;
&#13;
1. **编辑本地 SSH 配置文件**：首先，你需要编辑本地 SSH 配置文件，可以使用任何文本编辑器打开 `~/.ssh/config` 文件。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</guid><pubDate>Sun, 28 Jul 2024 09:24:43 +0000</pubDate></item><item><title>Linux用户与用户组的创建、切换及删除</title><link>https://echozap.github.io/post/Linux-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</link><description># 1创建新用户&#13;
&#13;
1. 以root用户身份登录到Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/Linux-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</guid><pubDate>Sun, 28 Jul 2024 09:15:25 +0000</pubDate></item><item><title>SSH 远程登录以及 SFTP 文件传输</title><link>https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</link><description>**SSH 默认端口号是22.**&#13;
&#13;
# SSH 远程登录主机&#13;
&#13;
```shell&#13;
ssh username@hostname&#13;
```&#13;
&#13;
其中，`username`是用户名，`hostname` 是主机名或IP 地址。</description><guid isPermaLink="true">https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</guid><pubDate>Sun, 28 Jul 2024 09:07:40 +0000</pubDate></item><item><title>Mac以指纹授权sudo指令的</title><link>https://echozap.github.io/post/Mac-yi-zhi-wen-shou-quan-sudo-zhi-ling-de.html</link><description>使用以下命令打开；&#13;
&#13;
```zsh&#13;
sudo vim /etc/pam.d/sudo&#13;
```&#13;
&#13;
出现以下内容：&#13;
&#13;
```zsh&#13;
  1 # sudo: auth account password session&#13;
  2 auth       include        sudo_local&#13;
  3 auth       sufficient     pam_smartcard.so&#13;
  4 auth       required       pam_opendirectory.so&#13;
  5 account    required       pam_permit.so&#13;
  6 password   required       pam_deny.so&#13;
  7 session    required       pam_permit.so&#13;
```&#13;
&#13;
&#13;
将下面这一行&#13;
&#13;
```plain&#13;
auth sufficient pam_smartcard.so&#13;
```&#13;
&#13;
修改为&#13;
&#13;
```plain&#13;
auth sufficient pam_tid.so&#13;
```&#13;
&#13;
保存并退出即可。</description><guid isPermaLink="true">https://echozap.github.io/post/Mac-yi-zhi-wen-shou-quan-sudo-zhi-ling-de.html</guid><pubDate>Sun, 28 Jul 2024 09:04:06 +0000</pubDate></item><item><title>mac合盖不休眠、安装包损坏解决办法</title><link>https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</link><description># 'app已损坏，无法打开'问题解决方法&#13;
&#13;
```shell&#13;
sudo xattr -rd com.apple.quarantine &lt;your_app_path&gt;&#13;
```&#13;
&#13;
将`your_app_path`替换成app路径，可以直接将应用程序里的app图标拖到终端窗口的这条命令里，按回车键执行。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</guid><pubDate>Sun, 28 Jul 2024 08:49:50 +0000</pubDate></item><item><title>sdcc工程创建模版程序</title><link>https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</link><description>## 1.程序构建&#13;
&#13;
新建一个txt文件并将以下代码复制到`xxx.txt`，之后将`xxx.txt（例如sdccpj.txt）`后缀名修改为`.sh（例如sdccpj.sh）`或者直接去掉后缀名只保留文件名（这在类linux系统中就是可执行程序）`sdccpj`。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</guid><pubDate>Sun, 28 Jul 2024 06:45:46 +0000</pubDate></item><item><title>Makefile</title><link>https://echozap.github.io/post/Makefile.html</link><description>## 1.规则&#13;
&#13;
&gt; Makefile的框架是由规则构成的。</description><guid isPermaLink="true">https://echozap.github.io/post/Makefile.html</guid><pubDate>Sun, 28 Jul 2024 06:36:41 +0000</pubDate></item><item><title>黄玄博客博文批量修改元信息</title><link>https://echozap.github.io/post/huang-xuan-bo-ke-bo-wen-pi-liang-xiu-gai-yuan-xin-xi.html</link><description>&gt; [!note]&#13;
&gt;&#13;
&gt; 改脚本适用于黄玄博客模板仓库&#13;
&gt;&#13;
&gt; 可以批量修改本地文件夹中所有md文件的头部元数据以适应仓库提交格式&#13;
&#13;
```shell&#13;
#!/usr/bin/env bash&#13;
&#13;
# 检查是否提供了目录路径参数&#13;
if [[ $# != 1 ]]; then&#13;
    echo 'Usage: $0 &lt;directory&gt;'&#13;
    exit 1&#13;
fi&#13;
&#13;
# 检查目录是否存在&#13;
if [ ! -d '$1' ]; then&#13;
    echo 'Directory '$1' not found.'&#13;
    exit 1&#13;
fi&#13;
&#13;
&#13;
read -p '' &#13;
&#13;
for file in '$1'/*.md; do&#13;
    # 获取文件名（不带后缀名、未加日期时间前缀以及绝对路径）&#13;
    issue_name=${${file%.md}##*/}&#13;
&#13;
    # 定义要追加的内容&#13;
    cont='---&#13;
layout:       post&#13;
title:        '${issue_name}'&#13;
author:       'Ronan'&#13;
header-style: text&#13;
catalog:      true&#13;
tags:&#13;
    - linux&#13;
    - shell&#13;
---'&#13;
&#13;
    # 获取（/Users/iaa/Desktop/s）&#13;
    pre_name=${file%/*}&#13;
&#13;
    # posts_name获取（2024-05-17-filename.md）&#13;
    posts_name='$(date +%Y-%m-%d)-${file##*/}' &#13;
&#13;
    new_name='${pre_name}/${posts_name}'&#13;
    mv $file $new_name   &#13;
&#13;
    # 创建临时文件存储内容&#13;
    temp=$(mktemp)&#13;
&#13;
    # 将内容写入临时文件&#13;
    {&#13;
    echo '$cont'&#13;
    echo '' # 添加一个空行&#13;
    cat '$new_name'&#13;
    } &gt; '$temp'&#13;
&#13;
    # 用临时文件的内容覆盖原文件&#13;
    mv '$temp' '$new_name'&#13;
&#13;
    echo 'Content added to the top of $new_name successfully.'&#13;
&#13;
done&#13;
&#13;
echo 'All jobs done...'&#13;
```&#13;
&#13;
&#13;
&lt;!-- ##{'timestamp':1722140467}## --&gt;。</description><guid isPermaLink="true">https://echozap.github.io/post/huang-xuan-bo-ke-bo-wen-pi-liang-xiu-gai-yuan-xin-xi.html</guid><pubDate>Sun, 28 Jul 2024 04:21:07 +0000</pubDate></item><item><title>静态库与动态库</title><link>https://echozap.github.io/post/jing-tai-ku-yu-dong-tai-ku.html</link><description>不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。</description><guid isPermaLink="true">https://echozap.github.io/post/jing-tai-ku-yu-dong-tai-ku.html</guid><pubDate>Sun, 28 Jul 2024 03:36:47 +0000</pubDate></item><item><title>SSH 免密登录</title><link>https://echozap.github.io/post/SSH%20-mian-mi-deng-lu.html</link><description># 1创建密钥&#13;
&#13;
在本地主机终端输入&#13;
&#13;
```shell&#13;
ssh-keygen&#13;
```&#13;
&#13;
之后一路回车，不出意外的话，你将看到以下内容&#13;
&#13;
![img](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/ssh-keygen.png)&#13;
&#13;
恭喜，你已经完成第一步！&#13;
&#13;
---&#13;
&#13;
# 2检查密钥是否创建成功&#13;
&#13;
在终端输入&#13;
&#13;
```shell&#13;
ls .ssh&#13;
```&#13;
&#13;
看到以下内容&#13;
&#13;
![img](https://cdn.jsdelivr.net/gh/EchoZap/echozap.github.io@main/static/imgs/ls_.ssh.png)&#13;
&#13;
看到其中有`id_ed25519`(私钥))**其中的ed25519在不同设备可能会有不同，有的可能是id_rsa**、`id_ed25519.pub`(公钥)两个文件，恭喜，你已经完成第二步了，离成功更近了！&#13;
&#13;
---&#13;
&#13;
# 3将公钥复制到远程主机&#13;
&#13;
在终端键入&#13;
&#13;
```shell&#13;
ssh-copy-id -i &lt;~/.ssh/id_ed25519.pub&gt; &lt;username&gt;@&lt;remote_ip&gt;&#13;
```&#13;
&#13;
其中的`&lt;~/.ssh/id_ed25519.pub&gt;` 是公钥所处的路径，`&lt;username&gt;`是用户名，`&lt;remote_ip&gt;`是主机名或IP 地址。</description><guid isPermaLink="true">https://echozap.github.io/post/SSH%20-mian-mi-deng-lu.html</guid><pubDate>Sun, 28 Jul 2024 03:19:49 +0000</pubDate></item><item><title>Typora图床自动上传脚本</title><link>https://echozap.github.io/post/Typora-tu-chuang-zi-dong-shang-chuan-jiao-ben.html</link><description>&gt; [!caution]&#13;
&gt; typroa的图片上传脚本，针对[Telegraph-Image](https://github.com/cf-pages/Telegraph-Image)项目，适用于macOS和Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/Typora-tu-chuang-zi-dong-shang-chuan-jiao-ben.html</guid><pubDate>Sun, 28 Jul 2024 03:03:04 +0000</pubDate></item><item><title>sdcc编译与链接</title><link>https://echozap.github.io/post/sdcc-bian-yi-yu-lian-jie.html</link><description>## 1.编译源文件&#13;
&#13;
首先，你需要编译你的源文件（例如 `main.c`）以生成目标文件（.rel）。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc-bian-yi-yu-lian-jie.html</guid><pubDate>Sat, 27 Jul 2024 07:37:39 +0000</pubDate></item><item><title>shell 编程</title><link>https://echozap.github.io/post/shell%20-bian-cheng.html</link><description># 一、运算符&#13;
&#13;
## 1、算术运算符&#13;
&#13;
下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：&#13;
&#13;
|运算符|说明|举例|&#13;
| :----: | :-------------------------------------------: | :------------------------: |&#13;
|+|加法|`expr $a + $b` 结果为 30。</description><guid isPermaLink="true">https://echozap.github.io/post/shell%20-bian-cheng.html</guid><pubDate>Sat, 27 Jul 2024 07:33:17 +0000</pubDate></item><item><title>vscode搭建用于8051单片机的sdcc环境</title><link>https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</link><description># 查找sdcc以及8051头文件位置&#13;
&#13;
```shell&#13;
❯ which sdcc&#13;
&#13;
/opt/homebrew/bin//sdcc&#13;
```&#13;
&#13;
这将列出sdcc的安装位置。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</guid><pubDate>Sat, 27 Jul 2024 07:26:20 +0000</pubDate></item><item><title>vscode磨砂效果配置</title><link>https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</link><description>## 1.安装插件&#13;
&#13;
在vscode安装以下插件。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</guid><pubDate>Sat, 27 Jul 2024 01:44:00 +0000</pubDate></item><item><title>PlatformIO烧录失败解决方法</title><link>https://echozap.github.io/post/PlatformIO-shao-lu-shi-bai-jie-jue-fang-fa.html</link><description>## 遭遇问题&#13;
​***platformIO一直卡在烧录程序中，导致开发版一直处于断电状态***&#13;
![问题](https://wowpb.pages.dev/file/de26c769e7e33ab9a64bb.png)&#13;
&#13;
&#13;
## 解决方法&#13;
&#13;
将main.py里的这一行注释即可&#13;
![解决1](https://wowpb.pages.dev/file/09761eef7eccb03e78bf3.png)&#13;
&#13;
&#13;
该文件在以下路径&#13;
`~/.platformio/intel_mcs51/builder/main.py`&#13;
![解决2](https://wowpb.pages.dev/file/546b2d5e45c306275722c.png)&#13;
。</description><guid isPermaLink="true">https://echozap.github.io/post/PlatformIO-shao-lu-shi-bai-jie-jue-fang-fa.html</guid><pubDate>Sat, 22 Jun 2024 07:16:18 +0000</pubDate></item></channel></rss>