<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Ronan's Blog</title><link>https://echozap.github.io</link><description>接受过《中华人民共和国义务教育法》规定的完整「九年义务教育」，如今也是个「正儿八经」的「文化人」，目前的物理活动范围主要在「某东亚大国」。</description><copyright>Ronan's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/avatar.jpg</url><title>avatar</title><link>https://echozap.github.io</link></image><lastBuildDate>Sat, 22 Mar 2025 10:47:52 +0000</lastBuildDate><managingEditor>Ronan's Blog</managingEditor><ttl>60</ttl><webMaster>Ronan's Blog</webMaster><item><title>vscode磨砂效果配置</title><link>https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</link><description>## 1.安装插件

在vscode安装以下插件。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-mo-sha-xiao-guo-pei-zhi.html</guid><pubDate>Sat, 22 Mar 2025 10:47:31 +0000</pubDate></item><item><title>vscode搭建用于8051单片机的sdcc环境</title><link>https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</link><description># 安装sdcc

macOS 通过下面命令安装 sdcc 编译器：
```shell
brew install sdcc
```

# 查找sdcc以及8051头文件位置

```shell
❯ which sdcc

/opt/homebrew/bin//sdcc
```

这将列出sdcc的安装位置。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-da-jian-yong-yu-8051-dan-pian-ji-de-sdcc-huan-jing.html</guid><pubDate>Sat, 22 Mar 2025 10:47:06 +0000</pubDate></item><item><title>vscode个人配置文件</title><link>https://echozap.github.io/post/vscode-ge-ren-pei-zhi-wen-jian.html</link><description>&gt; 以下为个人自用配置文件，如需拷贝使用请将内容全部拷贝并替换掉 vscode 的原有 settings.json 内容。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode-ge-ren-pei-zhi-wen-jian.html</guid><pubDate>Sat, 22 Mar 2025 10:46:29 +0000</pubDate></item><item><title>vscode + stm32CubeMX + Makefile工程以及问题解决</title><link>https://echozap.github.io/post/vscode%20%2B%20stm32CubeMX%20%2B%20Makefile-gong-cheng-yi-ji-wen-ti-jie-jue.html</link><description>通过 STM32CubeMX 建立的 Makefile 工程，应该会有以下结构：

```shell
❯ tree test
test
├── Core
│   ├── Inc
│   └── Src
├── Drivers
│   ├── CMSIS
│   │   ├── Device
│   │   │   └── ST
│   │   │       └── STM32F1xx
│   │   │           ├── Include
│   │   │           ├── LICENSE.txt
│   │   │           └── Source
│   │   │               └── Templates
│   │   ├── Include
│   │   └── LICENSE.txt
│   └── STM32F1xx_HAL_Driver
│       ├── Inc
│       │   ├── Legacy
│       ├── LICENSE.txt
│       └── Src
├── Makefile
├── STM32F103C8Tx_FLASH.ld
├── build
├── startup_stm32f103xb.s
└── test.ioc
```

## 1.配置本机环境

为了能顺利使用通过 STM32CubeMX 建立的 Makefile 工程，你需要先安装完成以下准备：

- 安装 `arm-none-eabi-gcc` 交叉编译链
- 安装 `openOCD`
- 安装 `Make`

安装 `arm-none-eabi-gcc` 交叉编译链：

- windows：
  - 链接: [https://caiyun.139.com/m/i?145CFu8T4pzZ9](https://caiyun.139.com/m/i?145CFu8T4pzZ9)
  - 提取码:ifpa
    
- linux：
  - 链接: [https://caiyun.139.com/m/i?145CFu8QjVMxO](https://caiyun.139.com/m/i?145CFu8QjVMxO)
  - 提取码:sXCp
  
- macOS：
  - 链接: [https://caiyun.139.com/m/i?145CFaDB85q9C](https://caiyun.139.com/m/i?145CFaDB85q9C)
  - 提取码:OoEr
  
如果你是个 ~~大佬~~ ,当然大佬应该是不会看这种教程的，你喜欢自己构建的话，可以用下面的源码：

- 链接: [https://caiyun.139.com/m/i?145CGY0p8xYON](https://caiyun.139.com/m/i?145CGY0p8xYON)
- 提取码:t3bC

下载安装好编译链之后，将其放入到环境变量 `PATH` 中(至于具体步骤，百度一下，你就知道)

---

## 2.创建工程并去掉警告(红色波浪线)

&gt; vscode 需要提前安装 C/C++ 插件

1.新建一个 STM32CubeMX_projects 目录(以后的工程就统一放置在该目录下，建议不要放置在桌面，放在自己容易记忆的位置)，然后使用 vscode 打开该目录，并且将其保存为工作区，将工作区文件保存在希望的位置，以后可以通过双击该文件直接打开 STM32CubeMX_projects 工作区：

![设立工作区](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/vscode_stm32_makefile_config1.png)


2.在 STM32CubeMX 配置好工程，点击左侧选项卡，然后勾选绿色框里的选项选择 Makefile 导出：

![建立并导出工程](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/cubemx_makefile_project1.png)
![建立并导出工程](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/cubemx_makefile_project2.png)

3.使用 vscode 打开该工程目录，点开`./Core/Src/main.c`，你会发现：满是令人高血压的红色波浪线，难以忍受。</description><guid isPermaLink="true">https://echozap.github.io/post/vscode%20%2B%20stm32CubeMX%20%2B%20Makefile-gong-cheng-yi-ji-wen-ti-jie-jue.html</guid><pubDate>Sat, 22 Mar 2025 10:45:57 +0000</pubDate></item><item><title>stm32程序烧录方式</title><link>https://echozap.github.io/post/stm32-cheng-xu-shao-lu-fang-shi.html</link><description>&gt; 以下以stm32f103c8t6芯片为例

## 使用stlink

```bash
st-flash write /path/project/build.bin 0x08000000
```

注意：

- 使用 `st-flash` 命令需要提前安装 stlink ，macOS 通过`brew install stlink`即可安装。</description><guid isPermaLink="true">https://echozap.github.io/post/stm32-cheng-xu-shao-lu-fang-shi.html</guid><pubDate>Sat, 22 Mar 2025 10:45:16 +0000</pubDate></item><item><title>SSH 远程登录以及 SFTP 文件传输</title><link>https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</link><description>**SSH 默认端口号是22.**

# SSH 远程登录主机

```shell
ssh username@hostname
```

其中，`username`是用户名，`hostname` 是主机名或IP 地址。</description><guid isPermaLink="true">https://echozap.github.io/post/SSH%20-yuan-cheng-deng-lu-yi-ji-%20SFTP%20-wen-jian-chuan-shu.html</guid><pubDate>Sat, 22 Mar 2025 10:44:46 +0000</pubDate></item><item><title>shell 编程</title><link>https://echozap.github.io/post/shell%20-bian-cheng.html</link><description># 一、运算符

## 1、算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

|运算符|说明|举例|
| :----: | :-------------------------------------------: | :------------------------: |
|+|加法|`expr $a + $b` 结果为 30。</description><guid isPermaLink="true">https://echozap.github.io/post/shell%20-bian-cheng.html</guid><pubDate>Sat, 22 Mar 2025 10:43:53 +0000</pubDate></item><item><title>shell 文本、字符串处理</title><link>https://echozap.github.io/post/shell%20-wen-ben-%E3%80%81-zi-fu-chuan-chu-li.html</link><description>## 1、字符串切片
＄{变量：偏移量：截取长度｝

```shell
--------------------------example
[192.168.2.230] - root@ubuntu20.04.5-template:/ root
$ MYPATH=' /usr/bin/wget'

[192.168.2.230］ - root@ubuntu20.04.5-template:/root
$ echo ${MYPATH: 4:4}
/bin     			  #其会左向右从第四位向后取四位（字符串第一位为0）

[192.168.2.230] - root@ubuntu20.04.5-template:/ root
$ echo ${MYPATH: -4}  #这会右向左从末尾向前取四位，「-4和冒号之间要有一个空格」
```

## 2、基于模式取子串
${var#*word}
其中word可以是指定的任意字符，自左而右，删除字符串开头至第一次出现word字符之间的所有字符。</description><guid isPermaLink="true">https://echozap.github.io/post/shell%20-wen-ben-%E3%80%81-zi-fu-chuan-chu-li.html</guid><pubDate>Sat, 22 Mar 2025 10:43:30 +0000</pubDate></item><item><title>sdcc 编译与链接</title><link>https://echozap.github.io/post/sdcc%20-bian-yi-yu-lian-jie.html</link><description>## 1.编译源文件

首先，你需要编译你的源文件（例如 `main.c`）以生成目标文件（.rel）。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc%20-bian-yi-yu-lian-jie.html</guid><pubDate>Sat, 22 Mar 2025 10:43:02 +0000</pubDate></item><item><title>sdcc工程创建模版程序</title><link>https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</link><description>## 1.程序构建

新建一个txt文件并将以下代码复制到`xxx.txt`，之后将`xxx.txt（例如sdccpj.txt）`后缀名修改为`.sh（例如sdccpj.sh）`或者直接去掉后缀名只保留文件名（这在类linux系统中就是可执行程序）`sdccpj`。</description><guid isPermaLink="true">https://echozap.github.io/post/sdcc-gong-cheng-chuang-jian-mo-ban-cheng-xu.html</guid><pubDate>Sat, 22 Mar 2025 10:42:32 +0000</pubDate></item><item><title>HuxproBlog 备份自动化</title><link>https://echozap.github.io/post/HuxproBlog%20-bei-fen-zi-dong-hua.html</link><description>&gt; 本文仅适用于[Huxpro 博客及其模板](https://github.com/Huxpro/huxpro.github.io) ！！！

# 准备 `backup.py` 以及 `backup`

1.在 `仓库根目录` 下新建一个 backup 空目录，「为防止 github 自动忽略空目录，所以可以在backup 里面随便新建一个 t.md」  
2.将以下代码保存为 `backup.py` 并且放置到 `仓库根目录` 下

backup.py 源码：

```python
import os
import re
import argparse

class Backup:

    def __init__(self, source_path, backup):
        # 备份的文档路径
        self.backup = backup
        # 带日期前缀的博文目录
        self.source_path = source_path

    def process_file(self, file_name):
        # 去掉文件元数据和名称前面的日期

        removing_date_file = re.sub(r'^\d{4}-\d{2}-\d{2}-', '', file_name)

        # 读取文件内容并移除 YAML 前置事项
        with open(f'{self.source_path}/{file_name}', 'r', encoding='utf-8') as file:
            content = file.read()

        # 使用正则表达式找到并去掉第一个以“---”分隔的部分
        content = re.sub(r'^---.*?---\s*', '', content, flags=re.DOTALL)

        # 将修改后的内容写入新的文件
        with open(f'{self.backup}/{removing_date_file}', 'w', encoding='utf-8') as new_file:
            new_file.write(content)

    def delete_old_file(self):
        # 获取 backup 目录下的所有 md 文件
        backup_files = {f for f in os.listdir(self.backup) if f.endswith('.md')}

        # 获取 _posts 目录下的所有 md 文件
        source_files = {f for f in os.listdir(self.source_path) if f.endswith('.md')}

        # 获得_posts 目录下去除日期后的文件名的集合
        intermediate_name = {re.sub(r'^\d{4}-\d{2}-\d{2}-', '', f) for f in source_files}

        # 找出在 backup 目录中但不在 source 目录中的文件
        unmatched_files = backup_files - intermediate_name

        # 删除这些不一致的文件
        for file_name in unmatched_files:
            file_path = os.path.join(self.backup, file_name)
            os.remove(file_path)

    def get_post_name(self) -&gt; list[str]:

        post_names = []
        for post_name in os.listdir(self.source_path):
            if post_name.endswith('.md') or post_name.endswith('.txt'):
                post_names.append(post_name)

        return post_names

def main():
    parser = argparse.ArgumentParser(description='Process a file to remove date from filename and YAML front matter.')

    # 添加一个位置参数来接受文件路径
    parser.add_argument('source_path', type=str, help='需要备份的目录')
    parser.add_argument('backup', type=str, help='备份文件存放的目录')

    # 解析命令行参数
    args = parser.parse_args()

    # 创建 Backup 类的实例
    backup = Backup(args.source_path, args.backup)
    post_names = backup.get_post_name()

    for post_name in post_names:
        backup.process_file(post_name)

    backup.delete_old_file()

    print('backup succeed')

if __name__ == '__main__':
    main()
```

# 修改actions
将仓库根目录下的 `.github/workflows/jekyll.yml` 内容修改为：

```yml

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# Sample workflow for building and deploying a Jekyll site to GitHub Pages
name: Deploy Jekyll site to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ['main']

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: 'pages'
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4



      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.12

      - name: Install dependencies
        run: |
          pip install --upgrade pip

      - name: Run backup script
        run: |
          python backup.py _posts backup

      - name: Commit and push backup files
        run: |
          git config --local user.email 'action@github.com'
          git config --local user.name 'GitHub Action'
          git add .
          git commit -m 'Updates backup files' || echo 'No changes to commit'
          git push



      - name: Setup Ruby
        uses: ruby/setup-ruby@8575951200e472d5f2d95c625da0c7bec8217c42 # v1.161.0
        with:
          ruby-version: '3.1' # Not needed with a .ruby-version file
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
          cache-version: 0 # Increment this number if you need to re-download cached gems

      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5

      - name: Build with Jekyll
        # Outputs to the './_site' directory by default
        run: bundle exec jekyll build --baseurl '${{ steps.pages.outputs.base_path }}'
        env:
          JEKYLL_ENV: production

      - name: Upload artifact
        # Automatically uploads an artifact from the './_site' directory by default
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```


#### actions改动的位置

`.github/workflows/jekyll.yml` 改动的位置是：

1. `permissions` 里的 contents 设置为 write
2. 在 biuld 工作流里添加了关于 backup.py 的使用

```yml
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# Sample workflow for building and deploying a Jekyll site to GitHub Pages
name: Deploy Jekyll site to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ['main']

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: 'pages'
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@8575951200e472d5f2d95c625da0c7bec8217c42 # v1.161.0
        with:
          ruby-version: '3.1' # Not needed with a .ruby-version file
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
          cache-version: 0 # Increment this number if you need to re-download cached gems

      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5

      - name: Build with Jekyll
        # Outputs to the './_site' directory by default
        run: bundle exec jekyll build --baseurl '${{ steps.pages.outputs.base_path }}'
        env:
          JEKYLL_ENV: production

      - name: Upload artifact
        # Automatically uploads an artifact from the './_site' directory by default
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```
。</description><guid isPermaLink="true">https://echozap.github.io/post/HuxproBlog%20-bei-fen-zi-dong-hua.html</guid><pubDate>Sat, 22 Mar 2025 10:42:04 +0000</pubDate></item><item><title>PyInstaller将Python应用打包为Android应用程序</title><link>https://echozap.github.io/post/PyInstaller-jiang-Python-ying-yong-da-bao-wei-Android-ying-yong-cheng-xu.html</link><description>在移动应用开发中，Python虽然不如Java或Kotlin那样广泛使用，但仍有一部分开发者偏爱使用Python进行开发。</description><guid isPermaLink="true">https://echozap.github.io/post/PyInstaller-jiang-Python-ying-yong-da-bao-wei-Android-ying-yong-cheng-xu.html</guid><pubDate>Sat, 22 Mar 2025 10:41:23 +0000</pubDate></item><item><title>OpenOCD 烧录失败解决方法</title><link>https://echozap.github.io/post/OpenOCD%20-shao-lu-shi-bai-jie-jue-fang-fa.html</link><description># 在烧录时遇到如下问题：

```shell
❯ openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c 'program /path/project/build.bin verify reset exit 0x08000000' 
                                                                                                             
openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c 'program build/final.bin verify reset exit 0x08000000'
Open On-Chip Debugger 0.12.0
Licensed under GNU GPL v2
For bug reports, read
       http://openocd.org/doc/doxygen/bugs.html
WARNING: interface/stlink-v2.cfg is deprecated, please switch to interface/stlink.cfg
Info : auto-selecting first available session transport 'hla_swd'. To override use 'transport select &lt;transport&gt;'.
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
Info : clock speed 1000 kHz
Info : STLINK V2J45M30 (API v2) VID:PID 0483:374B
Info : Target voltage: 3.269241
Warn : UNEXPECTED idcode: 0x1ba01477
Error: expected 1 of 1: 0x2ba01477
in procedure 'program'
** OpenOCD init failed **
shutdown command invoked
make: *** [flash] Error 1
```

---

# 解决方法
在  /opt/homebrew/Cellar/open-ocd/0.12.0_1/share/openocd/scripts/target（根据自己安装 OpenOCD 的位置查找，通过 brew 安装的就在这个位置）找到符合自己单片机型号的 cfg 文件，例如 stm32f1x.cfg 。</description><guid isPermaLink="true">https://echozap.github.io/post/OpenOCD%20-shao-lu-shi-bai-jie-jue-fang-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:40:31 +0000</pubDate></item><item><title>Makefile</title><link>https://echozap.github.io/post/Makefile.html</link><description>## 1.规则

&gt; Makefile的框架是由规则构成的。</description><guid isPermaLink="true">https://echozap.github.io/post/Makefile.html</guid><pubDate>Sat, 22 Mar 2025 10:39:46 +0000</pubDate></item><item><title>mac合盖不休眠、安装包损坏解决办法</title><link>https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</link><description># 'app已损坏，无法打开'问题解决方法

```shell
sudo xattr -rd com.apple.quarantine &lt;your_app_path&gt;
```

将`your_app_path`替换成app路径，可以直接将应用程序里的app图标拖到终端窗口的这条命令里，按回车键执行。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-he-gai-bu-xiu-mian-%E3%80%81-an-zhuang-bao-sun-huai-jie-jue-ban-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:39:21 +0000</pubDate></item><item><title>mac使用主机名代替IP地址进行ssh连接</title><link>https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</link><description># 1编辑本地SSH配置文件

1. **编辑本地 SSH 配置文件**：首先，你需要编辑本地 SSH 配置文件，可以使用任何文本编辑器打开 `~/.ssh/config` 文件。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-shi-yong-zhu-ji-ming-dai-ti-IP-di-zhi-jin-xing-ssh-lian-jie.html</guid><pubDate>Sat, 22 Mar 2025 10:38:54 +0000</pubDate></item><item><title>mac以指纹授权sudo指令</title><link>https://echozap.github.io/post/mac-yi-zhi-wen-shou-quan-sudo-zhi-ling.html</link><description>使用以下命令打开；

```zsh
sudo vim /etc/pam.d/sudo
```

出现以下内容：

```zsh
  1 # sudo: auth account password session
  2 auth       include        sudo_local
  3 auth       sufficient     pam_smartcard.so
  4 auth       required       pam_opendirectory.so
  5 account    required       pam_permit.so
  6 password   required       pam_deny.so
  7 session    required       pam_permit.so
```


将下面这一行

```plain
auth sufficient pam_smartcard.so
```

修改为

```plain
auth sufficient pam_tid.so
```

保存并退出即可
。</description><guid isPermaLink="true">https://echozap.github.io/post/mac-yi-zhi-wen-shou-quan-sudo-zhi-ling.html</guid><pubDate>Sat, 22 Mar 2025 10:38:28 +0000</pubDate></item><item><title>macOS 电池管理脚本</title><link>https://echozap.github.io/post/macOS%20-dian-chi-guan-li-jiao-ben.html</link><description>将以下内容保存为 `power_manager.sh` 并放入系统环境变量的路径中，接下来可通过 `nohup /path/power_manager.sh &amp;` 来实现后台运行

```shell
#!/bin/zsh

# 关闭休眠
disable_sleep() {
    sudo pmset -b sleep 0
    sudo pmset -b disablesleep 1
}

# 启用休眠
enable_sleep() {
    sudo pmset -b sleep 5
    sudo pmset -b disablesleep 0
}

while true; do

    LOG_FILE='～/power_manager.log'

    # 获取电脑盖子状态
    lid_state=$(ioreg -r -k AppleClamshellState -d 4 | grep AppleClamshellState | head -1 | awk '{print $NF}')

    # 获取电源连接状态
    ac_state=$(pmset -g batt | head -1)

    if [[ $lid_state == 'Yes' ]]; then
    # 合盖状态
        if [[ $ac_state =~ 'AC' ]]; then
            # 连接电源，关闭休眠并立即保持系统唤醒
            disable_sleep
        else
            # 未连接电源，开启休眠并立即进入休眠
            enable_sleep
            pmset sleepnow
        fi
    else
    # 开盖状态
        if [[ $ac_state =~ 'AC' ]]; then
            # 连接电源，关闭休眠并保持系统唤醒
            disable_sleep
        else
            # 未连接电源，开启休眠但不立即进入休眠
            enable_sleep
        fi
    fi
    sleep 5
done
```
。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS%20-dian-chi-guan-li-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:37:27 +0000</pubDate></item><item><title>macOS去除重复PATH环境变量</title><link>https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</link><description>&gt; 环境变量分为系统和用户，这里主要配置用户环境

在 macOS 上，全局的系统环境变量文件通常可以通过以下文件和目录来配置：

1. **`/etc/profile`**：

- 这是系统范围的 shell 配置文件，适用于所有用户。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</guid><pubDate>Sat, 22 Mar 2025 10:36:52 +0000</pubDate></item><item><title>linux 用户与用户组的创建、切换及删除</title><link>https://echozap.github.io/post/linux%20-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</link><description># 1创建新用户

1. 以root用户身份登录到Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/linux%20-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</guid><pubDate>Sat, 22 Mar 2025 10:35:53 +0000</pubDate></item><item><title>linux 查看或修改主机名</title><link>https://echozap.github.io/post/linux%20-cha-kan-huo-xiu-gai-zhu-ji-ming.html</link><description># 1查看当前主机名

```plain
hostname
```

这将会显示当前的主机名，或者

```zsh
cat /etc/hostname
```
  

# 2修改主机名

使用以下命令设置新主机名

```zsh
sudo hostnamectl set-hostname &lt;new_hostname&gt;
```

之后在文件中找到包含旧主机名的行，并将其替换为新主机名。</description><guid isPermaLink="true">https://echozap.github.io/post/linux%20-cha-kan-huo-xiu-gai-zhu-ji-ming.html</guid><pubDate>Sat, 22 Mar 2025 10:35:08 +0000</pubDate></item><item><title>JavaScript 常用用法</title><link>https://echozap.github.io/post/JavaScript%20-chang-yong-yong-fa.html</link><description># 获取 DOM 节点

### 1.选择匹配到的第一个元素

**语法：**

```javascript
document.querySelector('css选择器')
```

**参数：**

包含一个或多个有效的css选择器 **字符串** ，查看 [更多css选择器](https://www.runoob.com/cssref/css-selectors.html)。</description><guid isPermaLink="true">https://echozap.github.io/post/JavaScript%20-chang-yong-yong-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:34:25 +0000</pubDate></item><item><title>JavaScript</title><link>https://echozap.github.io/post/JavaScript.html</link><description># 对象概述

什么是对象？对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合

![img](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/js1.png)

```js
var user = {
  name: 'itbaizhan',
  age: '13'
};
```

对象的每一个键名又称为“属性”（property），它的“键

值”可以是任何数据类型。</description><guid isPermaLink="true">https://echozap.github.io/post/JavaScript.html</guid><pubDate>Sat, 22 Mar 2025 10:33:45 +0000</pubDate></item><item><title>IPv6的使用</title><link>https://echozap.github.io/post/IPv6-de-shi-yong.html</link><description># 查看是否有 IPv6 地址

在终端中输入：

```shell
# macos
ifconfig | grep 'inet6'
```

如果返回的是类似下方（这里的演示运营商是移动），那说明你是有 IPv6 公网地址的：

![ipv6](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/IPv6_ifconfig.png)

这些地址分为两类： `本地链路地址` 和 `全局地址`，它们的前缀和作用不同。</description><guid isPermaLink="true">https://echozap.github.io/post/IPv6-de-shi-yong.html</guid><pubDate>Sat, 22 Mar 2025 10:33:00 +0000</pubDate></item><item><title>Huxpro-Blog上传脚本</title><link>https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</link><description># 用法

- **注意** `create_new_file_in_the_repo` 函数里的 `branch='main'` 参数，根据自身仓库分支修改

[点我查看代码](https://gist.github.com/EchoZap/07c04ba1df4c41a875b1f27ccf29c1c3)
。</description><guid isPermaLink="true">https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:32:33 +0000</pubDate></item><item><title>Hugo-Blog 上传脚本</title><link>https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</link><description>使用方法：
- 将下面代码保存在一个 py 文件中，之后运行即可。</description><guid isPermaLink="true">https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:31:17 +0000</pubDate></item><item><title>GDB 调试</title><link>https://echozap.github.io/post/GDB%20-diao-shi.html</link><description>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。</description><guid isPermaLink="true">https://echozap.github.io/post/GDB%20-diao-shi.html</guid><pubDate>Sat, 22 Mar 2025 10:23:11 +0000</pubDate></item><item><title>GCC 使用及编译流程</title><link>https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</link><description>**GCC** 是 Linux 下的编译工具集，是 **GNU Compiler Collection** 的缩写，包含 gcc、g++ 等编译器。</description><guid isPermaLink="true">https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</guid><pubDate>Sat, 22 Mar 2025 10:22:43 +0000</pubDate></item><item><title>fire，一个强大的「Python」库</title><link>https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</link><description>Github地址：[https://github.com/google/python-fire](https://github.com/google/python-fire)

在开发命令行工具时，开发者通常需要编写大量代码来解析命令行参数，这既耗时又容易出错。</description><guid isPermaLink="true">https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</guid><pubDate>Sat, 22 Mar 2025 10:22:10 +0000</pubDate></item><item><title>ffmpeg 常用用法</title><link>https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</link><description>## 不改变原视频码率裁剪
### 废话少说，直接举栗🌰
1.从 `1时15分25秒` 开始裁剪到视频结束： 
```shell
ffmpeg -i input.mp4 -ss 01:15:25 -c copy output.mp4
``` 

2.从 `视频开始到15分5秒` ：
```shell
ffmpeg -i input.mp4 -to 00:15:05 -c copy output.mp4
```  

3.从 `15分25秒` 到  `1时15分25秒` ：
```shell
ffmpeg -i input.mp4 -ss 15:25 -to 01:15:25 -c copy output.mp4
``` 
  
`-i` 指定输入视频路径，`input.mp4`是要裁剪的视频文件的路径， `-ss` 裁剪视频起始时间，`-to` 裁剪视频结束时间，`-c copy` 在裁剪时不改变视频编码，从而保持原始视频码率， `output.mp4` 为裁剪后的视频文件。</description><guid isPermaLink="true">https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:21:04 +0000</pubDate></item><item><title>Docker常用命令</title><link>https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</link><description>![DockerCheatSheet.png](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/docker_command.png)

# 启动docker 

```shell
sudo service docker start
```

# 授予 docker sudo 权限

```shell
sudo usermod -aG docker $USER
```


# 列出所有已下载镜像

```shell
docker images
```

# 列出当前所有容器

```shell
docker ps -a
```

输出详情介绍：

- **CONTAINER ID:**  容器 ID。</description><guid isPermaLink="true">https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</guid><pubDate>Sat, 22 Mar 2025 10:20:22 +0000</pubDate></item><item><title>Dockerfile的简单实现</title><link>https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</link><description># 构建第一个Dockerfile

假设该镜像实现的等同于我们在已经配置好python环境的机器上通过`python hello.py`命令来运行一个python脚本

所以该Dockerfile的构建有以下步骤：

1. 在桌面或其他位置新建一个文件夹，假设文件夹名为docker
2. 在docker新建一个hello.py文件，hello.py已经实现所需功能
3. 再在docker新建一个`Dockerfile`，**注意：仅开头且必须大写**

以下是Dockerfile内容：

```shell
 
FROM python:3.9.19-alpine3.18
COPY hello.py /hello.py
 
CMD python hello.py
```

# Dockerfile语法说明

`Dockerfile` 是 Docker 构建镜像的描述文件，它包含了一系列指令，描述了如何从基础镜像创建一个新的 Docker 镜像。</description><guid isPermaLink="true">https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</guid><pubDate>Sat, 22 Mar 2025 10:19:18 +0000</pubDate></item></channel></rss>