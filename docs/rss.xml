<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Ronan's Blog</title><link>https://echozap.github.io</link><description>接受过《中华人民共和国义务教育法》规定的完整「九年义务教育」，如今也是个「正儿八经」的「文化人」，目前的物理活动范围主要在「某东亚大国」。</description><copyright>Ronan's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/avatar.jpg</url><title>avatar</title><link>https://echozap.github.io</link></image><lastBuildDate>Sat, 22 Mar 2025 10:33:26 +0000</lastBuildDate><managingEditor>Ronan's Blog</managingEditor><ttl>60</ttl><webMaster>Ronan's Blog</webMaster><item><title>IPv6的使用</title><link>https://echozap.github.io/post/IPv6-de-shi-yong.html</link><description># 查看是否有 IPv6 地址

在终端中输入：

```shell
# macos
ifconfig | grep 'inet6'
```

如果返回的是类似下方（这里的演示运营商是移动），那说明你是有 IPv6 公网地址的：

![ipv6](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/IPv6_ifconfig.png)

这些地址分为两类： `本地链路地址` 和 `全局地址`，它们的前缀和作用不同。</description><guid isPermaLink="true">https://echozap.github.io/post/IPv6-de-shi-yong.html</guid><pubDate>Sat, 22 Mar 2025 10:33:00 +0000</pubDate></item><item><title>Huxpro-Blog上传脚本</title><link>https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</link><description># 用法

- **注意** `create_new_file_in_the_repo` 函数里的 `branch='main'` 参数，根据自身仓库分支修改

[点我查看代码](https://gist.github.com/EchoZap/07c04ba1df4c41a875b1f27ccf29c1c3)
。</description><guid isPermaLink="true">https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:32:33 +0000</pubDate></item><item><title>Hugo-Blog 上传脚本</title><link>https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</link><description>使用方法：
- 将下面代码保存在一个 py 文件中，之后运行即可。</description><guid isPermaLink="true">https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:31:17 +0000</pubDate></item><item><title>GDB 调试</title><link>https://echozap.github.io/post/GDB%20-diao-shi.html</link><description>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。</description><guid isPermaLink="true">https://echozap.github.io/post/GDB%20-diao-shi.html</guid><pubDate>Sat, 22 Mar 2025 10:23:11 +0000</pubDate></item><item><title>GCC 使用及编译流程</title><link>https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</link><description>**GCC** 是 Linux 下的编译工具集，是 **GNU Compiler Collection** 的缩写，包含 gcc、g++ 等编译器。</description><guid isPermaLink="true">https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</guid><pubDate>Sat, 22 Mar 2025 10:22:43 +0000</pubDate></item><item><title>fire，一个强大的「Python」库</title><link>https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</link><description>Github地址：[https://github.com/google/python-fire](https://github.com/google/python-fire)

在开发命令行工具时，开发者通常需要编写大量代码来解析命令行参数，这既耗时又容易出错。</description><guid isPermaLink="true">https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</guid><pubDate>Sat, 22 Mar 2025 10:22:10 +0000</pubDate></item><item><title>ffmpeg 常用用法</title><link>https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</link><description>## 不改变原视频码率裁剪
### 废话少说，直接举栗🌰
1.从 `1时15分25秒` 开始裁剪到视频结束： 
```shell
ffmpeg -i input.mp4 -ss 01:15:25 -c copy output.mp4
``` 

2.从 `视频开始到15分5秒` ：
```shell
ffmpeg -i input.mp4 -to 00:15:05 -c copy output.mp4
```  

3.从 `15分25秒` 到  `1时15分25秒` ：
```shell
ffmpeg -i input.mp4 -ss 15:25 -to 01:15:25 -c copy output.mp4
``` 
  
`-i` 指定输入视频路径，`input.mp4`是要裁剪的视频文件的路径， `-ss` 裁剪视频起始时间，`-to` 裁剪视频结束时间，`-c copy` 在裁剪时不改变视频编码，从而保持原始视频码率， `output.mp4` 为裁剪后的视频文件。</description><guid isPermaLink="true">https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:21:04 +0000</pubDate></item><item><title>Docker常用命令</title><link>https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</link><description>![DockerCheatSheet.png](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/docker_command.png)

# 启动docker 

```shell
sudo service docker start
```

# 授予 docker sudo 权限

```shell
sudo usermod -aG docker $USER
```


# 列出所有已下载镜像

```shell
docker images
```

# 列出当前所有容器

```shell
docker ps -a
```

输出详情介绍：

- **CONTAINER ID:**  容器 ID。</description><guid isPermaLink="true">https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</guid><pubDate>Sat, 22 Mar 2025 10:20:22 +0000</pubDate></item><item><title>Dockerfile的简单实现</title><link>https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</link><description># 构建第一个Dockerfile

假设该镜像实现的等同于我们在已经配置好python环境的机器上通过`python hello.py`命令来运行一个python脚本

所以该Dockerfile的构建有以下步骤：

1. 在桌面或其他位置新建一个文件夹，假设文件夹名为docker
2. 在docker新建一个hello.py文件，hello.py已经实现所需功能
3. 再在docker新建一个`Dockerfile`，**注意：仅开头且必须大写**

以下是Dockerfile内容：

```shell
 
FROM python:3.9.19-alpine3.18
COPY hello.py /hello.py
 
CMD python hello.py
```

# Dockerfile语法说明

`Dockerfile` 是 Docker 构建镜像的描述文件，它包含了一系列指令，描述了如何从基础镜像创建一个新的 Docker 镜像。</description><guid isPermaLink="true">https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</guid><pubDate>Sat, 22 Mar 2025 10:19:18 +0000</pubDate></item></channel></rss>