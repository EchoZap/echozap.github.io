<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Ronan's Blog</title><link>https://echozap.github.io</link><description>接受过《中华人民共和国义务教育法》规定的完整「九年义务教育」，如今也是个「正儿八经」的「文化人」，目前的物理活动范围主要在「某东亚大国」。</description><copyright>Ronan's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/avatar.jpg</url><title>avatar</title><link>https://echozap.github.io</link></image><lastBuildDate>Sat, 22 Mar 2025 10:37:50 +0000</lastBuildDate><managingEditor>Ronan's Blog</managingEditor><ttl>60</ttl><webMaster>Ronan's Blog</webMaster><item><title>macOS 电池管理脚本</title><link>https://echozap.github.io/post/macOS%20-dian-chi-guan-li-jiao-ben.html</link><description>将以下内容保存为 `power_manager.sh` 并放入系统环境变量的路径中，接下来可通过 `nohup /path/power_manager.sh &amp;` 来实现后台运行

```shell
#!/bin/zsh

# 关闭休眠
disable_sleep() {
    sudo pmset -b sleep 0
    sudo pmset -b disablesleep 1
}

# 启用休眠
enable_sleep() {
    sudo pmset -b sleep 5
    sudo pmset -b disablesleep 0
}

while true; do

    LOG_FILE='～/power_manager.log'

    # 获取电脑盖子状态
    lid_state=$(ioreg -r -k AppleClamshellState -d 4 | grep AppleClamshellState | head -1 | awk '{print $NF}')

    # 获取电源连接状态
    ac_state=$(pmset -g batt | head -1)

    if [[ $lid_state == 'Yes' ]]; then
    # 合盖状态
        if [[ $ac_state =~ 'AC' ]]; then
            # 连接电源，关闭休眠并立即保持系统唤醒
            disable_sleep
        else
            # 未连接电源，开启休眠并立即进入休眠
            enable_sleep
            pmset sleepnow
        fi
    else
    # 开盖状态
        if [[ $ac_state =~ 'AC' ]]; then
            # 连接电源，关闭休眠并保持系统唤醒
            disable_sleep
        else
            # 未连接电源，开启休眠但不立即进入休眠
            enable_sleep
        fi
    fi
    sleep 5
done
```
。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS%20-dian-chi-guan-li-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:37:27 +0000</pubDate></item><item><title>macOS去除重复PATH环境变量</title><link>https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</link><description>&gt; 环境变量分为系统和用户，这里主要配置用户环境

在 macOS 上，全局的系统环境变量文件通常可以通过以下文件和目录来配置：

1. **`/etc/profile`**：

- 这是系统范围的 shell 配置文件，适用于所有用户。</description><guid isPermaLink="true">https://echozap.github.io/post/macOS-qu-chu-zhong-fu-PATH-huan-jing-bian-liang.html</guid><pubDate>Sat, 22 Mar 2025 10:36:52 +0000</pubDate></item><item><title>linux 用户与用户组的创建、切换及删除</title><link>https://echozap.github.io/post/linux%20-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</link><description># 1创建新用户

1. 以root用户身份登录到Linux系统。</description><guid isPermaLink="true">https://echozap.github.io/post/linux%20-yong-hu-yu-yong-hu-zu-de-chuang-jian-%E3%80%81-qie-huan-ji-shan-chu.html</guid><pubDate>Sat, 22 Mar 2025 10:35:53 +0000</pubDate></item><item><title>linux 查看或修改主机名</title><link>https://echozap.github.io/post/linux%20-cha-kan-huo-xiu-gai-zhu-ji-ming.html</link><description># 1查看当前主机名

```plain
hostname
```

这将会显示当前的主机名，或者

```zsh
cat /etc/hostname
```
  

# 2修改主机名

使用以下命令设置新主机名

```zsh
sudo hostnamectl set-hostname &lt;new_hostname&gt;
```

之后在文件中找到包含旧主机名的行，并将其替换为新主机名。</description><guid isPermaLink="true">https://echozap.github.io/post/linux%20-cha-kan-huo-xiu-gai-zhu-ji-ming.html</guid><pubDate>Sat, 22 Mar 2025 10:35:08 +0000</pubDate></item><item><title>JavaScript 常用用法</title><link>https://echozap.github.io/post/JavaScript%20-chang-yong-yong-fa.html</link><description># 获取 DOM 节点

### 1.选择匹配到的第一个元素

**语法：**

```javascript
document.querySelector('css选择器')
```

**参数：**

包含一个或多个有效的css选择器 **字符串** ，查看 [更多css选择器](https://www.runoob.com/cssref/css-selectors.html)。</description><guid isPermaLink="true">https://echozap.github.io/post/JavaScript%20-chang-yong-yong-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:34:25 +0000</pubDate></item><item><title>JavaScript</title><link>https://echozap.github.io/post/JavaScript.html</link><description># 对象概述

什么是对象？对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型

简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合

![img](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/js1.png)

```js
var user = {
  name: 'itbaizhan',
  age: '13'
};
```

对象的每一个键名又称为“属性”（property），它的“键

值”可以是任何数据类型。</description><guid isPermaLink="true">https://echozap.github.io/post/JavaScript.html</guid><pubDate>Sat, 22 Mar 2025 10:33:45 +0000</pubDate></item><item><title>IPv6的使用</title><link>https://echozap.github.io/post/IPv6-de-shi-yong.html</link><description># 查看是否有 IPv6 地址

在终端中输入：

```shell
# macos
ifconfig | grep 'inet6'
```

如果返回的是类似下方（这里的演示运营商是移动），那说明你是有 IPv6 公网地址的：

![ipv6](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/IPv6_ifconfig.png)

这些地址分为两类： `本地链路地址` 和 `全局地址`，它们的前缀和作用不同。</description><guid isPermaLink="true">https://echozap.github.io/post/IPv6-de-shi-yong.html</guid><pubDate>Sat, 22 Mar 2025 10:33:00 +0000</pubDate></item><item><title>Huxpro-Blog上传脚本</title><link>https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</link><description># 用法

- **注意** `create_new_file_in_the_repo` 函数里的 `branch='main'` 参数，根据自身仓库分支修改

[点我查看代码](https://gist.github.com/EchoZap/07c04ba1df4c41a875b1f27ccf29c1c3)
。</description><guid isPermaLink="true">https://echozap.github.io/post/Huxpro-Blog-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:32:33 +0000</pubDate></item><item><title>Hugo-Blog 上传脚本</title><link>https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</link><description>使用方法：
- 将下面代码保存在一个 py 文件中，之后运行即可。</description><guid isPermaLink="true">https://echozap.github.io/post/Hugo-Blog%20-shang-chuan-jiao-ben.html</guid><pubDate>Sat, 22 Mar 2025 10:31:17 +0000</pubDate></item><item><title>GDB 调试</title><link>https://echozap.github.io/post/GDB%20-diao-shi.html</link><description>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。</description><guid isPermaLink="true">https://echozap.github.io/post/GDB%20-diao-shi.html</guid><pubDate>Sat, 22 Mar 2025 10:23:11 +0000</pubDate></item><item><title>GCC 使用及编译流程</title><link>https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</link><description>**GCC** 是 Linux 下的编译工具集，是 **GNU Compiler Collection** 的缩写，包含 gcc、g++ 等编译器。</description><guid isPermaLink="true">https://echozap.github.io/post/GCC%20-shi-yong-ji-bian-yi-liu-cheng.html</guid><pubDate>Sat, 22 Mar 2025 10:22:43 +0000</pubDate></item><item><title>fire，一个强大的「Python」库</title><link>https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</link><description>Github地址：[https://github.com/google/python-fire](https://github.com/google/python-fire)

在开发命令行工具时，开发者通常需要编写大量代码来解析命令行参数，这既耗时又容易出错。</description><guid isPermaLink="true">https://echozap.github.io/post/fire%EF%BC%8C-yi-ge-qiang-da-de-%E3%80%8CPython%E3%80%8D-ku.html</guid><pubDate>Sat, 22 Mar 2025 10:22:10 +0000</pubDate></item><item><title>ffmpeg 常用用法</title><link>https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</link><description>## 不改变原视频码率裁剪
### 废话少说，直接举栗🌰
1.从 `1时15分25秒` 开始裁剪到视频结束： 
```shell
ffmpeg -i input.mp4 -ss 01:15:25 -c copy output.mp4
``` 

2.从 `视频开始到15分5秒` ：
```shell
ffmpeg -i input.mp4 -to 00:15:05 -c copy output.mp4
```  

3.从 `15分25秒` 到  `1时15分25秒` ：
```shell
ffmpeg -i input.mp4 -ss 15:25 -to 01:15:25 -c copy output.mp4
``` 
  
`-i` 指定输入视频路径，`input.mp4`是要裁剪的视频文件的路径， `-ss` 裁剪视频起始时间，`-to` 裁剪视频结束时间，`-c copy` 在裁剪时不改变视频编码，从而保持原始视频码率， `output.mp4` 为裁剪后的视频文件。</description><guid isPermaLink="true">https://echozap.github.io/post/ffmpeg%20-chang-yong-yong-fa.html</guid><pubDate>Sat, 22 Mar 2025 10:21:04 +0000</pubDate></item><item><title>Docker常用命令</title><link>https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</link><description>![DockerCheatSheet.png](https://pub-a25b6a83a2d846958fb63f69d07d79a5.r2.dev/docker_command.png)

# 启动docker 

```shell
sudo service docker start
```

# 授予 docker sudo 权限

```shell
sudo usermod -aG docker $USER
```


# 列出所有已下载镜像

```shell
docker images
```

# 列出当前所有容器

```shell
docker ps -a
```

输出详情介绍：

- **CONTAINER ID:**  容器 ID。</description><guid isPermaLink="true">https://echozap.github.io/post/Docker-chang-yong-ming-ling.html</guid><pubDate>Sat, 22 Mar 2025 10:20:22 +0000</pubDate></item><item><title>Dockerfile的简单实现</title><link>https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</link><description># 构建第一个Dockerfile

假设该镜像实现的等同于我们在已经配置好python环境的机器上通过`python hello.py`命令来运行一个python脚本

所以该Dockerfile的构建有以下步骤：

1. 在桌面或其他位置新建一个文件夹，假设文件夹名为docker
2. 在docker新建一个hello.py文件，hello.py已经实现所需功能
3. 再在docker新建一个`Dockerfile`，**注意：仅开头且必须大写**

以下是Dockerfile内容：

```shell
 
FROM python:3.9.19-alpine3.18
COPY hello.py /hello.py
 
CMD python hello.py
```

# Dockerfile语法说明

`Dockerfile` 是 Docker 构建镜像的描述文件，它包含了一系列指令，描述了如何从基础镜像创建一个新的 Docker 镜像。</description><guid isPermaLink="true">https://echozap.github.io/post/Dockerfile-de-jian-dan-shi-xian.html</guid><pubDate>Sat, 22 Mar 2025 10:19:18 +0000</pubDate></item></channel></rss>